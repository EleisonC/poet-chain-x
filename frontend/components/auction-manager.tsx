"use client"

import { useState } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Badge } from "@/components/ui/badge"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { Gavel, Eye, Send } from "lucide-react"
import { createInkSdk } from "@polkadot-api/sdk-ink"
import { createClient } from "polkadot-api"
import { withPolkadotSdkCompat } from "polkadot-api/polkadot-sdk-compat"
import { getWsProvider } from "polkadot-api/ws-provider"
import { contracts } from "../.papi/descriptors/dist"
import {
  getInjectedExtensions,
  connectInjectedExtension,
  InjectedExtension,
  InjectedPolkadotAccount,
} from "polkadot-api/pjs-signer"

interface AuctionManagerProps {
  account: string
}

export function AuctionManager({ account }: AuctionManagerProps) {
  const [contractAddress, setContractAddress] = useState("")
  const [bidAmount, setBidAmount] = useState("")
  const [isLoading, setIsLoading] = useState(false)
  const [poemText, setPoemText] = useState("")
  const [currentBid, setCurrentBid] = useState("")
  const [highestBidder, setHighestBidder] = useState("")
  const [endBlock, setEndBlock] = useState(0)
  const [currentBlock, setCurrentBlock] = useState(0)
  const [auctionIsActive, setAuctionIsActive] = useState(Boolean)

  const handlePlaceBid = async () => {
    if (!contractAddress || !bidAmount) return
    if (bidAmount < currentBid) alert("Bid placed is low")

    setIsLoading(true)
    try {
      const client = createClient(
        withPolkadotSdkCompat(
          getWsProvider([
            "wss://testnet-passet-hub.polkadot.io",
            "wss://passet-hub-paseo.ibp.network",
          ]),
        ),
      )
      const poetChainInkSdk = createInkSdk(client) // poetChainInkSdk
        // Read the contract file
      console.log("Your account is mapped?", await poetChainInkSdk.addressIsMapped(account))

      const poetChainXContract = poetChainInkSdk.getContract(contracts.poet_chain_x, contractAddress)
      console.log("Here is what we need to see", poetChainXContract)

      const extensions: string[] = getInjectedExtensions()
      const selectedExtension: InjectedExtension = await connectInjectedExtension(extensions[0])
      const accounts: InjectedPolkadotAccount[] = selectedExtension.getAccounts()
      const matching = accounts.find((acc) => acc.address === account)
      const polkadotSigner = matching
        ? matching.polkadotSigner
        : accounts[0].polkadotSigner

      const poetBidResult = await poetChainXContract
      .send("bid", {
        origin: account,
        value: BigInt(bidAmount)
      })
      .signAndSubmit(polkadotSigner)

      if (poetBidResult.ok) {
        console.log("block", poetBidResult.block)
        // The events generated by this contract can also be filtered using `filterEvents`:
        console.log("events", poetChainXContract.filterEvents(poetBidResult.events))
      } else {
        console.log("error", poetBidResult.dispatchError)
      }
      alert("Bid placed successfully!")
    } catch (error) {
      console.error("Failed to place bid:", error)
    } finally {
      setIsLoading(false)
    }
  }

  const handleEndAuction = async () => {
    if (!contractAddress) return
    if (!auctionIsActive) return

    setIsLoading(true)
    try {
      const client = createClient(
        withPolkadotSdkCompat(
          getWsProvider([
            "wss://testnet-passet-hub.polkadot.io",
            "wss://passet-hub-paseo.ibp.network",
          ]),
        ),
      )
      const poetChainInkSdk = createInkSdk(client) // poetChainInkSdk
        // Read the contract file
      console.log("Your account is mapped?", await poetChainInkSdk.addressIsMapped(account))

      const poetChainXContract = poetChainInkSdk.getContract(contracts.poet_chain_x, contractAddress)
      console.log("Here End Auction", poetChainXContract)

      const extensions: string[] = getInjectedExtensions()
      const selectedExtension: InjectedExtension = await connectInjectedExtension(extensions[0])
      const accounts: InjectedPolkadotAccount[] = selectedExtension.getAccounts()
      const matching = accounts.find((acc) => acc.address === account)
      const polkadotSigner = matching
        ? matching.polkadotSigner
        : accounts[0].polkadotSigner

      const poetBidResult = await poetChainXContract
      .send("end_auction", {
        origin: account,
      })
      .signAndSubmit(polkadotSigner)
      alert("Auction ended successfully!")
    } catch (error) {
      console.error("Failed to end auction:", error)
    } finally {
      setIsLoading(false)
    }
  }

  const handleGetContract = async () => {
    if (!contractAddress) return

    setIsLoading(true)
    try {
          const client = createClient(
            withPolkadotSdkCompat(
              getWsProvider([
                "wss://testnet-passet-hub.polkadot.io",
                "wss://passet-hub-paseo.ibp.network",
              ]),
            ),
          )
          const poetChainInkSdk = createInkSdk(client) // poetChainInkSdk
           // Read the contract file
          console.log("Your account is mapped?", await poetChainInkSdk.addressIsMapped(account))

          const poetChainXContract = poetChainInkSdk.getContract(contracts.poet_chain_x, contractAddress)
          console.log("Here is what we need to see", poetChainXContract)

          // const result = await flipperContract.query("get", {
          //   origin: ALICE,
          // })
          
          // if (result.success) {
          //   console.log("flip value", result.value.response)
          //   console.log("events", result.value.events)
          
          //   // The dry-run result also has a method to get the transaction to send the same message to the contract.
          //   const callResult = await result.value.send().signAndSubmit(aliceSigner)
          // } else {
          //   console.log("error", result.value)
          // }

          const peomInfo = await poetChainXContract.query("get_poem", {
            origin: account
          })
          
          if (peomInfo.success) {
            setPoemText(peomInfo.value.response)
          }

          const highBidder = await poetChainXContract.query("get_winner",{
            origin: account
          })
          if (highBidder.success) {
            setHighestBidder(highBidder.value.response[0]?.asText() || "No Bidder")
            setCurrentBid(highBidder.value.response[1].toString())
          }

          const auction_info = await poetChainXContract.query("get_auction_info", {
            origin: account
          })
          if (auction_info.success) {
            setEndBlock(auction_info.value.response[1])
            setAuctionIsActive(auction_info.value.response[2])
            setCurrentBlock(auction_info.value.response[0])

          }

    } catch (error) {
      console.error("Failed to end auction:", error)
    } finally {
      setIsLoading(false)
    }
  }



  return (
    <div className="space-y-6">
      <Card>
        <CardHeader>
          <CardTitle>Interact with Auction Contract</CardTitle>
          <CardDescription>Enter a contract address to view and interact with an auction</CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="space-y-2">
            <Label htmlFor="contract-address">Contract Address</Label>
            <div className="flex gap-2">
              <Input
                id="contract-address"
                placeholder="5F69jP7VwzCp6pGZ93mv9FkAhwnwz4scR4J9asNeSgFPUGLq"
                value={contractAddress}
                onChange={(e) => setContractAddress(e.target.value)}
                className="font-mono text-sm"
              />
              <Button
              onClick={handleGetContract}
              variant="outline" className="gap-2 bg-transparent">
                <Eye className="h-4 w-4" />
                Load
              </Button>
            </div>
          </div>
        </CardContent>
      </Card>

      {contractAddress && (
        <Card>
          <CardHeader>
            <div className="flex items-start justify-between">
              <Badge variant={auctionIsActive ? "default" : "secondary"}>
                {auctionIsActive ? "Active" : "Ended"}
              </Badge>
            </div>
          </CardHeader>
          <CardContent className="space-y-6">
            <div className="bg-muted p-4 rounded-lg">
              <p className="text-sm whitespace-pre-line leading-relaxed">{poemText}</p>
            </div>

            <div className="grid grid-cols-2 gap-4">
              <div className="space-y-1">
                <p className="text-sm text-muted-foreground">Current Highest Bid</p>
                <p className="text-2xl font-bold">{currentBid} PAS</p>
              </div>
              <div className="space-y-1">
                <p className="text-sm text-muted-foreground">Blocks Remaining</p>
                <p className="text-2xl font-bold">{endBlock - currentBlock}</p>
              </div>
            </div>

            <div className="space-y-1">
              <p className="text-sm text-muted-foreground">Highest Bidder</p>
              <p className="font-mono text-sm">
                {highestBidder.slice(0, 10)}...{highestBidder.slice(-8)}
              </p>
            </div>

            <Tabs defaultValue="bid" className="w-full">
              <TabsList className="grid w-full grid-cols-2">
                <TabsTrigger value="bid">Place Bid</TabsTrigger>
                <TabsTrigger value="end">End Auction</TabsTrigger>
              </TabsList>
              <TabsContent value="bid" className="space-y-4">
                <div className="space-y-2">
                  <Label htmlFor="bid-amount">Bid Amount (PAS)</Label>
                  <Input
                    id="bid-amount"
                    type="number"
                    placeholder="6.0"
                    value={bidAmount}
                    onChange={(e) => setBidAmount(e.target.value)}
                    min={Number.parseFloat(currentBid.toString()) + 0.1}
                    step="0.1"
                  />
                  <p className="text-xs text-muted-foreground">
                    Must be higher than current bid ({currentBid} PAS)
                  </p>
                </div>
                <Button onClick={handlePlaceBid} disabled={!bidAmount || isLoading} className="w-full gap-2">
                  <Gavel className="h-4 w-4" />
                  {isLoading ? "Placing Bid..." : "Place Bid"}
                </Button>
              </TabsContent>
              <TabsContent value="end" className="space-y-4">
                <div className="bg-muted p-4 rounded-lg text-sm space-y-2">
                  <p className="font-semibold">End Auction</p>
                  <p className="text-muted-foreground">
                    Only available after block {endBlock}. This will transfer the highest bid to the seller
                    and mark the auction as complete.
                  </p>
                </div>
                <Button
                  onClick={handleEndAuction}
                  disabled={currentBlock < endBlock || isLoading}
                  variant="secondary"
                  className="w-full gap-2"
                >
                  <Send className="h-4 w-4" />
                  {isLoading ? "Ending Auction..." : "End Auction"}
                </Button>
              </TabsContent>
            </Tabs>
          </CardContent>
        </Card>
      )}
    </div>
  )
}
